<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CRTS: CRTSFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CRTS
   &#160;<span id="projectnumber">Version 0.3</span>
   </div>
   <div id="projectbrief">Cognitive Radio Test System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classCRTSFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CRTSFilter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Filter_8hpp_source.html">Filter.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for CRTSFilter:</div>
<div class="dyncontent">
<div class="center"><img src="classCRTSFilter__coll__graph.png" border="0" usemap="#CRTSFilter_coll__map" alt="Collaboration graph"/></div>
<map name="CRTSFilter_coll__map" id="CRTSFilter_coll__map">
<area shape="rect" id="node2" href="classCRTSStream.html" title="CRTSStream" alt="" coords="5,5,107,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab75eb3db5914c0d6b3781439d46b2301"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input</a> (void *buffer, size_t bufferLen, uint32_t inputChannelNum)=0</td></tr>
<tr class="separator:ab75eb3db5914c0d6b3781439d46b2301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3e99b38a67fd40559776d468b95fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start</a> (uint32_t numInputChannels, uint32_t numOutputChannels)</td></tr>
<tr class="separator:a15a3e99b38a67fd40559776d468b95fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934e38c5cd6bd82b309166180f664f0c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a934e38c5cd6bd82b309166180f664f0c">stop</a> (uint32_t numInputChannels, uint32_t numOutputChannels)</td></tr>
<tr class="separator:a934e38c5cd6bd82b309166180f664f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d907e8b7d986f35a5cb31171f7d683f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a2d907e8b7d986f35a5cb31171f7d683f">CRTSFilter</a> (std::string controlName=&quot;&quot;)</td></tr>
<tr class="separator:a2d907e8b7d986f35a5cb31171f7d683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa6986d6a10ed56ea4af4ebcf41337e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCRTSStream.html">CRTSStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#aa6986d6a10ed56ea4af4ebcf41337e73">stream</a></td></tr>
<tr class="separator:aa6986d6a10ed56ea4af4ebcf41337e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9ea354654e8e2e8ce3bff293cc35fafe"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></td></tr>
<tr class="separator:a9ea354654e8e2e8ce3bff293cc35fafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af731176aa73539af3cfc69b6c1051f82"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#af731176aa73539af3cfc69b6c1051f82">NULL_CHANNEL</a></td></tr>
<tr class="separator:af731176aa73539af3cfc69b6c1051f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acacdf624ab19ae5ad6394a647dccc353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#acacdf624ab19ae5ad6394a647dccc353">isSource</a> (void)</td></tr>
<tr class="separator:acacdf624ab19ae5ad6394a647dccc353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7898d77d1a5acbadb45769eff2a01cfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a7898d77d1a5acbadb45769eff2a01cfb">advanceInput</a> (size_t len)</td></tr>
<tr class="separator:a7898d77d1a5acbadb45769eff2a01cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ee2e0151f822aec425d6d22ab94757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a33ee2e0151f822aec425d6d22ab94757">setParameter</a> (const std::string name, double value)</td></tr>
<tr class="separator:a33ee2e0151f822aec425d6d22ab94757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a10a3daf1d7ee26e8b414c16901b315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a7a10a3daf1d7ee26e8b414c16901b315">createOutputBuffer</a> (size_t maxLength, uint32_t outputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a>)</td></tr>
<tr class="separator:a7a10a3daf1d7ee26e8b414c16901b315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f53beaf044b384b94e1166a2c53ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#acc8f53beaf044b384b94e1166a2c53ca">createOutputBuffer</a> (size_t maxLength, const uint32_t *outputChannelNums)</td></tr>
<tr class="separator:acc8f53beaf044b384b94e1166a2c53ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462892f9ed127c6280f2e62f97aca5bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a462892f9ed127c6280f2e62f97aca5bc">createPassThroughBuffer</a> (uint32_t inputChannelNum, uint32_t outputChannelNum, size_t maxLength, size_t thresholdLength=0)</td></tr>
<tr class="separator:a462892f9ed127c6280f2e62f97aca5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b908a9f9ec81ff3b52a98f447b3bb4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a16b908a9f9ec81ff3b52a98f447b3bb4">getOutputBuffer</a> (uint32_t outputChannelNum)</td></tr>
<tr class="separator:a16b908a9f9ec81ff3b52a98f447b3bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d221e7b871d483f68c73c379fd08cd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a4d221e7b871d483f68c73c379fd08cd3">setInputThreshold</a> (size_t len, uint32_t inputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a>)</td></tr>
<tr class="separator:a4d221e7b871d483f68c73c379fd08cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa484e49c5a75c467209324930bc1a0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#aa484e49c5a75c467209324930bc1a0bf">setMaxUnreadLength</a> (size_t len, uint32_t inputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a>)</td></tr>
<tr class="separator:aa484e49c5a75c467209324930bc1a0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadfaf372947b1b7cbcb5667e6b74026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#acadfaf372947b1b7cbcb5667e6b74026">setChokeLength</a> (size_t len, uint32_t inputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a>)</td></tr>
<tr class="separator:acadfaf372947b1b7cbcb5667e6b74026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe899250f3aa73aa8eb5aed7dfc371de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output</a> (size_t len, uint32_t outputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a>)</td></tr>
<tr class="separator:afe899250f3aa73aa8eb5aed7dfc371de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2790e3d559443f54724a060b5abec4b7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a2790e3d559443f54724a060b5abec4b7">totalBytesIn</a> (uint32_t inputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">CRTSFilter::ALL_CHANNELS</a>) const</td></tr>
<tr class="separator:a2790e3d559443f54724a060b5abec4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67f7953354ba62d0b28fec0819abb7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#a4e67f7953354ba62d0b28fec0819abb7">totalBytesOut</a> (uint32_t outputChannelNum=<a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">CRTSFilter::ALL_CHANNELS</a>) const</td></tr>
<tr class="separator:a4e67f7953354ba62d0b28fec0819abb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc17d29240468c94e360e1b788f5d6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCRTSFilter.html#acc17d29240468c94e360e1b788f5d6a0">addParameter</a> (std::string name, std::function&lt; double(void)&gt; get, std::function&lt; bool(const double &amp;)&gt; set=0, bool overWrite=false)</td></tr>
<tr class="separator:acc17d29240468c94e360e1b788f5d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A filter component module base class.</p>
<p>We say that in general a filter reads inputs and writes outputs.</p>
<p>A source filter has no input and a sink filter has no output.</p>
<p>We use the word filter to refer to general data processing component. Systems engineers would likely not want to refer to these data processing components as filters, but strictly speaking they are software filters, ref: <a href="https://en.wikipedia.org/wiki/Filter_(software),">https://en.wikipedia.org/wiki/Filter_(software),</a> so we call them filters which is short for "software filters". Some <a class="el" href="classCRTSFilter.html">CRTSFilter</a> objects have zero input, but the interface to these filters with no inputs is the same as the filters with input, so they are filters with null inputs. We call them source filters.</p>
<p>The Unix philosophy encourages combining small, discrete tools to accomplish larger tasks. Reference: <a href="https://en.wikipedia.org/wiki/Filter_(software)#Unix">https://en.wikipedia.org/wiki/Filter_(software)#Unix</a></p>
<p>A stream can be thought of as items on a conveyor belt being processed one at a time. In our case in CRTSFilters are placed at points along the conveyor belt to transform the data stream as it flows. This idea of "stream" seems to fit what we are doing. We assemble CRTSFilters along our stream. Reference: <a href="https://en.wikipedia.org/wiki/Stream_(computing)">https://en.wikipedia.org/wiki/Stream_(computing)</a> <a href="https://en.wikipedia.org/wiki/Filter_(software)">https://en.wikipedia.org/wiki/Filter_(software)</a></p>
<p>When these modules run the coding interfaces are such that we do not have to know if these modules run on separate threads or not. Wither or not these modules run on different threads is decided at run time. This is a requirement so that run/start time optimization is possible.</p>
<p>Sometimes things are so simple that running a single thread is much faster than running more than one thread; and sometimes processing in a module takes so long that multi-threading, and multi-buffering between, the modules is faster. We can test different filter/thread topologies on the fly and the filter writer does not have to be concerned about threading, which is a run time decision. The cost for such flexibility is requiring a particular interface, the <a class="el" href="classCRTSFilter.html">CRTSFilter</a> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2d907e8b7d986f35a5cb31171f7d683f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d907e8b7d986f35a5cb31171f7d683f">&#9670;&nbsp;</a></span>CRTSFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRTSFilter::CRTSFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>controlName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the Super class constructor is called the filter connection topology is not yet known. The connection topology stays the same between the call of <a class="el" href="classCRTSFilter.html">CRTSFilter</a> <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> and <a class="el" href="classCRTSFilter.html#a934e38c5cd6bd82b309166180f664f0c">stop()</a>. After the constructor is called and after <a class="el" href="classCRTSFilter.html#a934e38c5cd6bd82b309166180f664f0c">stop()</a>, but before <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> the topology may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controlName</td><td>sets the name of the filter control. This name can be used by a <a class="el" href="classCRTSController.html">CRTSController</a> to get control of this filter. If <code>name</code> is an empty string a name will be generated based on the filename of the filter module plugin that is made with this <a class="el" href="classCRTSFilter.html">CRTSFilter</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc17d29240468c94e360e1b788f5d6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc17d29240468c94e360e1b788f5d6a0">&#9670;&nbsp;</a></span>addParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::addParameter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const double &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overWrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a controllable parameter to this filter.</p>
<p>This will make a parameter that is accessible by <a class="el" href="classCRTSController.html">CRTSController</a> modules.</p>
<p>Provides seamless parameterization.</p>
<p>This adds an interface of setting and getting parameter values for modular <a class="el" href="classCRTSController.html">CRTSController</a> objects. The CRTSControllers only have to know the <code>name</code> of the parameter to set and get its' value, they do not need more intimate knowledge about parameters to set and get them. In this way we say that we have a seamless interface to controlling the filters. This seamless interface enables use to make a generic shell controller that can control any and all of the filters without even knowing what the filters are, it just knows that it can set and get parameter values and the filter handles the detail.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>doubles can be converted to many other types, but a double can't be made into any type. If we template out the double we'll lose the seamless nature of this control interface, or will we.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the parameter that CRTSControllers will be setting and getting.</td></tr>
    <tr><td class="paramname">get</td><td>a function that returns the current parameter value, as the filter defines it. A get function is required.</td></tr>
    <tr><td class="paramname">set</td><td>a function that is called to set the parameter in whatever way it sees fit. A set function is not required. The <a class="el" href="classCRTSFilter.html">CRTSFilter</a> does not need to let external code set a parameter.</td></tr>
    <tr><td class="paramname">overWrite</td><td>if false this will not throw an exception due to already having a parameter with this name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7898d77d1a5acbadb45769eff2a01cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7898d77d1a5acbadb45769eff2a01cfb">&#9670;&nbsp;</a></span>advanceInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::advanceInput </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark len bytes as read from the input buffer for the current input channel.</p>
<p>It is not required to call this, but if it is not called in the filter modules <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> function the input buffer will automatically be advanced by the total number of bytes called with the <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> function. </p>

</div>
</div>
<a id="a7a10a3daf1d7ee26e8b414c16901b315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a10a3daf1d7ee26e8b414c16901b315">&#9670;&nbsp;</a></span>createOutputBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::createOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a buffer that will have data with origin from this <a class="el" href="classCRTSFilter.html">CRTSFilter</a>.</p>
<p>This function should only be called in the filters' <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLength</td><td>is the largest amount of data that will be written to this buffer. This filter must not <a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output()</a> more than <code>maxLength</code> bytes for the listed output channels.</td></tr>
    <tr><td class="paramname">outputChannelNum</td><td>is an output channel number. outputChannelNum must be less than numOutputChannels that was passed into the filters <code><a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">CRTSFilter::start()</a></code> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc8f53beaf044b384b94e1166a2c53ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8f53beaf044b384b94e1166a2c53ca">&#9670;&nbsp;</a></span>createOutputBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::createOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>outputChannelNums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a buffer that will have data with origin from this <a class="el" href="classCRTSFilter.html">CRTSFilter</a>. This creates one buffer that may have more than one output channel. The buffer will be shared between the channels.</p>
<p>This function should only be called in the filters' <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLength</td><td>is the largest amount of data that will be written to this buffer. This filter must not <a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output()</a> more than <code>maxLength</code> bytes for the listed output channels, in a single <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> call; otherwise the ring buffer may be overrun.</td></tr>
    <tr><td class="paramname">outputChannelNums</td><td>a <code>NULL_CHANNEL</code> terminated array of channels. For example: <div class="fragment"><div class="line">uint32_t outputChannelsNums[] = { 0, 2, 3, NULL_CHANNEL };</div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a462892f9ed127c6280f2e62f97aca5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462892f9ed127c6280f2e62f97aca5bc">&#9670;&nbsp;</a></span>createPassThroughBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::createPassThroughBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thresholdLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instead of allocating a ring buffer, we reuse the ring buffer from the channel associated with <code>inputChannelNum</code> to the output channel with channel number <code>outputChannelNum</code>.</p>
<p>This function should only be called in the filters' <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputChannelNum</td><td>an input channel number that we will get the buffer from.</td></tr>
    <tr><td class="paramname">outputChannelNum</td><td>an output channel number that we will use to <a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output()</a> with.</td></tr>
    <tr><td class="paramname">maxLength</td><td>the maximum number of bytes that we will leave unconsumed by the filter. Not consuming the input data on an input channel may lead to buffer overrun. You are promising to clean plate to this amount.</td></tr>
    <tr><td class="paramname">thresholdLength</td><td>is the input threshold that is needed to be archived before the filters <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> is called. During stream shutdown this threshold may not be archived before the filters <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> is called, otherwise the input would be lost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b908a9f9ec81ff3b52a98f447b3bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b908a9f9ec81ff3b52a98f447b3bb4">&#9670;&nbsp;</a></span>getOutputBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* CRTSFilter::getOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the current writing position of the buffer so the filter may write to the memory.</p>
<p>This buffer must have been created by the filter with <a class="el" href="classCRTSFilter.html#a7a10a3daf1d7ee26e8b414c16901b315">createOutputBuffer()</a> in the <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputChannelNum</td><td>the output channel number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab75eb3db5914c0d6b3781439d46b2301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75eb3db5914c0d6b3781439d46b2301">&#9670;&nbsp;</a></span>input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CRTSFilter::input </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function for receiving input into your filter.</p>
<p>The <a class="el" href="classCRTSFilter.html">CRTSFilter</a> super class (filter) must provide this function to receive input. This function will be called by the running crts_radio program as input data becomes available from the calling of <a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output()</a> in the filters that connect to this filter.</p>
<p>When this <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> function is called the stream may be running in one of two modes: </p><pre class="fragment"> 1. Normal running when stream-&gt;isRunning is true.  In this
 mode the amount of input data will always be at least as
 large as the requested threshold.

 2. Shutdown mode when stream-&gt;isRunning is false.  In
 shutdown mode all the source filters will no longer get
 their input() functions called and all the other
 non-source filters will get their input() called until all
 the flowing data runs out.  There may be one or more
 filter input() calls with the amount of input data that is
 less than the requested threshold amount.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>is a pointer to the start of the input data or 0 if <code>len</code> is 0 and this is a source filter.</td></tr>
    <tr><td class="paramname">bufferLen</td><td>is the number of bytes available to access in <code>buffer</code>.</td></tr>
    <tr><td class="paramname">inputChannelNum</td><td>is the designated input channel number for the the given input. This channel number is valid for this receiving filter. Both input and output channel numbers start at 0 and increase by one based on the order of when they are connected (kind of like file descriptors). There are never gaps in the channel number sequences. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acacdf624ab19ae5ad6394a647dccc353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacdf624ab19ae5ad6394a647dccc353">&#9670;&nbsp;</a></span>isSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CRTSFilter::isSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lets a <a class="el" href="classCRTSFilter.html">CRTSFilter</a> know if it is the source in a stream graph.</p>
<p>A source filter will continuously have its' <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> called with zero bytes of input until stream-&gt;isRunning is not true.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the filter is a source or false otherwise </dd></dl>

</div>
</div>
<a id="afe899250f3aa73aa8eb5aed7dfc371de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe899250f3aa73aa8eb5aed7dfc371de">&#9670;&nbsp;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::output </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write output to a given output channel.</p>
<p>Trigger a connected filter <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> call from the current filter, whereby writing <code>len</code> bytes to the filter connected to output channel <code>outputChannelNum</code> and advancing the write pointer in the ring buffer.</p>
<p>The amount of data consumed by the connected receiving filter can be different than, <code>len</code>, the length requested, because the consuming filter has the option of letting data accumulate before acting on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>length in bytes.</td></tr>
    <tr><td class="paramname">outputChannelNum</td><td>is the input channel number. Set <code>outputChannelNum</code> to <code>ALL_CHANNELS</code> to apply this to all channels from the filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acadfaf372947b1b7cbcb5667e6b74026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadfaf372947b1b7cbcb5667e6b74026">&#9670;&nbsp;</a></span>setChokeLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::setChokeLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum length, in bytes, which this filter will accept in its' <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> call on the given channel.</p>
<p>This can not be called when the stream is running, that is outside the <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the maximum length in bytes.</td></tr>
    <tr><td class="paramname">inputChannelNum</td><td>is the input channel number. Set <code>inputChannelNum</code> to <code>ALL_CHANNELS</code> to apply this to all channels in the filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d221e7b871d483f68c73c379fd08cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d221e7b871d483f68c73c379fd08cd3">&#9670;&nbsp;</a></span>setInputThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::setInputThreshold </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the minimum length, in bytes, that this <a class="el" href="classCRTSFilter.html">CRTSFilter</a> must accumulate before <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> can and will be called, for the given channel. This can only be called in the <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the threshold length in bytes.</td></tr>
    <tr><td class="paramname">inputChannelNum</td><td>is the input channel number. Set <code>inputChannelNum</code> to <code>ALL_CHANNELS</code> to apply this to all channels in the filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa484e49c5a75c467209324930bc1a0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa484e49c5a75c467209324930bc1a0bf">&#9670;&nbsp;</a></span>setMaxUnreadLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CRTSFilter::setMaxUnreadLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">ALL_CHANNELS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum length, in bytes, beyond which this filter promises to not leave unconsumed.</p>
<p>There may be input lengths to <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> larger than this due to adjcent filters having higher limits. This is just so the needed ring buffer size may be computed.</p>
<p>This can not be called when the stream is running, that is outside the <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the maximum length in bytes.</td></tr>
    <tr><td class="paramname">inputChannelNum</td><td>is the input channel number. Set <code>inputChannelNum</code> to <code>ALL_CHANNELS</code> to apply this to all channels in the filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33ee2e0151f822aec425d6d22ab94757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ee2e0151f822aec425d6d22ab94757">&#9670;&nbsp;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CRTSFilter::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a parameter in this filter.</p>
<p>This will call all the CRTSController::getParameter() callbacks that are registered. If there are no callbacks this call does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of this parameter to set.</td></tr>
    <tr><td class="paramname">value</td><td>is the value to set and send to the <a class="el" href="classCRTSController.html">CRTSController</a> callbacks functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success. </dd></dl>

</div>
</div>
<a id="a15a3e99b38a67fd40559776d468b95fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a3e99b38a67fd40559776d468b95fa">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CRTSFilter::start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInputChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numOutputChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called before the flow starts, or restarts. The flow will stop and restart any time the stream topology changes. The stream filter topology should be considered fixed until <a class="el" href="classCRTSFilter.html#a934e38c5cd6bd82b309166180f664f0c">stop()</a> is called.</p>
<p>The <a class="el" href="classCRTSFilter.html">CRTSFilter</a> writer may override this to take actions that depend on what input channels and output channels are present, like how buffers are shared between input channels and output channels.</p>
<p>The flow graph structure is not known when the <a class="el" href="classCRTSFilter.html">CRTSFilter</a> Super class constructor is called, so we must have this start interface to be called when that structure is known.</p>
<p>This may be used to start a piece of physical hardware.</p>
<p>At each start call the number of input and output channels can change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numInputChannels</td><td>the number of inputs. Input channels are numbers from 0 to N-1.</td></tr>
    <tr><td class="paramname">numOutputtChannels</td><td>the number of outputs. Output channels are numbers from 0 to N-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for failure. </dd></dl>

</div>
</div>
<a id="a934e38c5cd6bd82b309166180f664f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934e38c5cd6bd82b309166180f664f0c">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CRTSFilter::stop </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInputChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numOutputChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called after the flow stops and the stream topology has not changed yet. This may be due to the program heading toward exiting, or it may be due to a restart, in which case <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> will be called later.</p>
<p>The engineer on the star ship Enterprise may write this to shutdown the reactor core so the channels connections can be changed without having to handle live reactor conduits (channels).</p>
<p>This may or may not be needed for all <a class="el" href="classCRTSFilter.html">CRTSFilter</a> modules. It's so the Filter may stop a piece of physical hardware for a restart or shutdown like events.</p>
<p>At each stop call the number of input and output channels will be the same as that in the last <a class="el" href="classCRTSFilter.html#a15a3e99b38a67fd40559776d468b95fa">start()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numInputChannels</td><td>the number of inputs. Input channels are numbers from 0 to N-1.</td></tr>
    <tr><td class="paramname">numOutputtChannels</td><td>the number of outputs. Output channels are numbers from 0 to N-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for failure. </dd></dl>

</div>
</div>
<a id="a2790e3d559443f54724a060b5abec4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2790e3d559443f54724a060b5abec4b7">&#9670;&nbsp;</a></span>totalBytesIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CRTSFilter::totalBytesIn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">CRTSFilter::ALL_CHANNELS</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputChannelNum</td><td>is the input channel number. If <code>inputChannelNum</code> is to <code>ALL_CHANNELS</code> get the total for all input channels to this filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of bytes that the filters corresponding input channel has consumed. This does not include any concurrently running <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> calls, only calls to <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a> that have returned. </dd></dl>

</div>
</div>
<a id="a4e67f7953354ba62d0b28fec0819abb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e67f7953354ba62d0b28fec0819abb7">&#9670;&nbsp;</a></span>totalBytesOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CRTSFilter::totalBytesOut </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputChannelNum</em> = <code><a class="el" href="classCRTSFilter.html#a9ea354654e8e2e8ce3bff293cc35fafe">CRTSFilter::ALL_CHANNELS</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputChannelNum</td><td>is the output channel number. If <code>outputChannelNum</code> is to <code>ALL_CHANNELS</code> get the total for all output channels for this filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of bytes that has been written to the corresponding output channel for this filter. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9ea354654e8e2e8ce3bff293cc35fafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea354654e8e2e8ce3bff293cc35fafe">&#9670;&nbsp;</a></span>ALL_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t CRTSFilter::ALL_CHANNELS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A channel number used to refer to all channels be they input or output.</p>
<p>It may be used as the channel parameter to the functions: <a class="el" href="classCRTSFilter.html#ab75eb3db5914c0d6b3781439d46b2301">input()</a>, <a class="el" href="classCRTSFilter.html#afe899250f3aa73aa8eb5aed7dfc371de">output()</a>, <a class="el" href="classCRTSFilter.html#a7a10a3daf1d7ee26e8b414c16901b315">createOutputBuffer()</a>, <a class="el" href="classCRTSFilter.html#a462892f9ed127c6280f2e62f97aca5bc">createPassThroughBuffer()</a>, <a class="el" href="classCRTSFilter.html#a4d221e7b871d483f68c73c379fd08cd3">setInputThreshold()</a>, <a class="el" href="classCRTSFilter.html#aa484e49c5a75c467209324930bc1a0bf">setMaxUnreadLength()</a>, <a class="el" href="classCRTSFilter.html#acadfaf372947b1b7cbcb5667e6b74026">setChokeLength()</a>, <a class="el" href="classCRTSFilter.html#a16b908a9f9ec81ff3b52a98f447b3bb4">getOutputBuffer()</a>, <a class="el" href="classCRTSFilter.html#a2790e3d559443f54724a060b5abec4b7">totalBytesIn()</a>, and <a class="el" href="classCRTSFilter.html#a4e67f7953354ba62d0b28fec0819abb7">totalBytesOut()</a>. </p>

</div>
</div>
<a id="af731176aa73539af3cfc69b6c1051f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af731176aa73539af3cfc69b6c1051f82">&#9670;&nbsp;</a></span>NULL_CHANNEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t CRTSFilter::NULL_CHANNEL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A special channel number used to refer to no channel at all.</p>
<p>The value of <code>NULL_CHANNEL</code> is not 0, since 0 is a valid channel number. </p>

</div>
</div>
<a id="aa6986d6a10ed56ea4af4ebcf41337e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6986d6a10ed56ea4af4ebcf41337e73">&#9670;&nbsp;</a></span>stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCRTSStream.html">CRTSStream</a>* CRTSFilter::stream</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The stream that this filter object is in. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/progb/git/crts/include/crts/<a class="el" href="Filter_8hpp_source.html">Filter.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
